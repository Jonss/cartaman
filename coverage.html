
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>pg: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Jonss/cartaman/pkg/adapters/repository/pg/card_repository.go (85.7%)</option>
				
				<option value="file1">github.com/Jonss/cartaman/pkg/adapters/repository/pg/connection.go (62.5%)</option>
				
				<option value="file2">github.com/Jonss/cartaman/pkg/adapters/repository/pg/deck_repository.go (63.5%)</option>
				
				<option value="file3">github.com/Jonss/cartaman/pkg/adapters/repository/pg/test_utils.go (72.7%)</option>
				
				<option value="file4">github.com/Jonss/cartaman/pkg/ports/httprest/deck_handler.go (88.9%)</option>
				
				<option value="file5">github.com/Jonss/cartaman/pkg/ports/httprest/rest.go (100.0%)</option>
				
				<option value="file6">github.com/Jonss/cartaman/pkg/usecase/deck/common.go (0.0%)</option>
				
				<option value="file7">github.com/Jonss/cartaman/pkg/usecase/deck/create_deck_usecase.go (0.0%)</option>
				
				<option value="file8">github.com/Jonss/cartaman/pkg/usecase/deck/deck_service.go (0.0%)</option>
				
				<option value="file9">github.com/Jonss/cartaman/pkg/usecase/deck/draw_card_usecase.go (0.0%)</option>
				
				<option value="file10">github.com/Jonss/cartaman/pkg/usecase/deck/mocks/deck_service.go (100.0%)</option>
				
				<option value="file11">github.com/Jonss/cartaman/pkg/usecase/deck/open_deck_usecase.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package pg

import (
        "context"
        "database/sql"
        "fmt"
        "strings"
)

type PGCardRepository struct {
        DB *sql.DB
}

func NewPGCardRepository(db *sql.DB) PGCardRepository <span class="cov0" title="0">{
        return PGCardRepository{DB: db}
}</span>

func (r PGCardRepository) SeedCards(ctx context.Context) error <span class="cov4" title="10">{
        var quantity int
        err := r.DB.QueryRowContext(ctx, "select count(1) from cards").Scan(&amp;quantity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="10">if quantity &gt; 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov4" title="9">query := fmt.Sprintf(`INSERT INTO cards (suit, value, code) VALUES %s;`, buildCards())
        _, err = r.DB.ExecContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="9">return nil</span>
}

func (r PGCardRepository) GetCardIDs(ctx context.Context, codes []string) ([]int, error) <span class="cov2" title="3">{
        query := "SELECT id FROM cards"
        if len(codes) &gt;= 1 </span><span class="cov2" title="2">{
                query += fmt.Sprintf(" WHERE code IN ('%s');", strings.Join(codes, "','"))
        }</span>

        <span class="cov2" title="3">var IDs []int
        rows, err := r.DB.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return IDs, err
        }</span>

        <span class="cov2" title="3">for rows.Next() </span><span class="cov6" title="55">{
                var ID int
                err := rows.Scan(&amp;ID)
                if err != nil </span><span class="cov0" title="0">{
                        return IDs, err
                }</span>
                <span class="cov6" title="55">IDs = append(IDs, ID)</span>
        }

        <span class="cov2" title="3">return IDs, nil</span>
}

func buildCards() string <span class="cov4" title="9">{
        cardSuits := []string{"SPADES", "CLUBS", "DIAMONDS", "HEARTS"}
        cardValues := []string{"ACE", "2", "3", "4", "5", "6", "7", "8", "9", "10", "JACK", "QUEEN", "KING"}

        var strBuilder strings.Builder
        for _, s := range cardSuits </span><span class="cov6" title="36">{
                for _, v := range cardValues </span><span class="cov10" title="468">{
                        code := fmt.Sprintf("%c%c", v[0], s[0])
                        strBuilder.WriteString(fmt.Sprintf(" ('%s', '%s', '%s'),", s, v, code))
                }</span>
        }
        <span class="cov4" title="9">cards := strBuilder.String()
        return cards[:len(cards)-1]</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package pg

import (
        "database/sql"
        "fmt"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file" // migration
        _ "github.com/lib/pq"                                // postgres
)

func NewConnection(datasource string) (*sql.DB, error) <span class="cov10" title="9">{
        conn, err := sql.Open("postgres", datasource)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="9">return conn, err</span>
}

func Migrate(db *sql.DB, dbName, path string) error <span class="cov10" title="9">{
        driver, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error when migrate.WithInstance(): error=(%w)", err)
        }</span>
        <span class="cov10" title="9">m, err := migrate.NewWithDatabaseInstance("file://"+path, dbName, driver)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error when migrate.NewWithDatabaseInstance(): error=(%w)", err)
        }</span>

        <span class="cov10" title="9">err = m.Up()
        if err != nil </span><span class="cov0" title="0">{
                if err == migrate.ErrNoChange </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("error on migrate.Up(): error=(%w)", err)</span>
        }
        <span class="cov10" title="9">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package pg

import (
        "context"
        "database/sql"
        "errors"

        "github.com/Jonss/cartaman/pkg/adapters/repository"
        _ "github.com/golang-migrate/migrate/v4/source/file" // migration
        "github.com/google/uuid"
        _ "github.com/lib/pq" // postgres
)

type PGDeckRepository struct {
        DB *sql.DB
}

func NewPGDeckRepository(db *sql.DB) PGDeckRepository <span class="cov0" title="0">{
        return PGDeckRepository{DB: db}
}</span>

var _ repository.DeckRepository = (*PGDeckRepository)(nil)

func (r PGDeckRepository) CreateDeck(ctx context.Context, params repository.CreateDeckParams) (*repository.Deck, error) <span class="cov7" title="4">{
        if len(params.CardIDs) == 0 </span><span class="cov1" title="1">{
                return nil, errors.New("error expect cardIDs length &gt; 0")
        }</span>

        <span class="cov5" title="3">tx, err := r.DB.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="3">query := `INSERT INTO decks (external_id, is_shuffled) values ($1, $2) RETURNING id`

        var deckID int
        err = tx.QueryRowContext(ctx, query, params.ExternalID, params.Shuffled).Scan(&amp;deckID)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, err
        }</span>

        <span class="cov5" title="3">for _, cardID := range params.CardIDs </span><span class="cov10" title="8">{
                query = `INSERT INTO decks_cards (card_id, deck_id) VALUES ($1, $2)`
                _, err := tx.ExecContext(ctx, query, cardID, deckID)
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return nil, err
                }</span>
        }

        <span class="cov5" title="3">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="3">deck := &amp;repository.Deck{
                ID:         deckID,
                ExternalID: params.ExternalID,
                Shuffled:   params.Shuffled,
                Remaining:  len(params.CardIDs),
        }
        return deck, nil</span>
}

func (r PGDeckRepository) FetchDeck(ctx context.Context, deckID uuid.UUID) (*repository.OpenDeck, error) <span class="cov7" title="4">{
        query := `
        SELECT d.id, d.external_id, c.suit, c.value, c.code
        FROM decks d
        INNER JOIN decks_cards dc
        ON d.id = dc.deck_id
        INNER JOIN cards c
        ON c.id = dc.card_id
        WHERE d.external_id = $1
        AND dc.is_drew IS false
        `
        rows, err := r.DB.QueryContext(ctx, query, deckID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="4">var openDeck repository.OpenDeck
        var cards []repository.Card
        for rows.Next() </span><span class="cov8" title="6">{
                var card repository.Card
                err := rows.Scan(&amp;openDeck.Deck.ID, &amp;openDeck.Deck.ExternalID, &amp;card.Suit, &amp;card.Value, &amp;card.Code)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="6">cards = append(cards, card)</span>
        }
        <span class="cov7" title="4">if openDeck.Deck.ID == 0 </span><span class="cov1" title="1">{
                return nil, repository.ErrorDeckNotFound
        }</span>

        <span class="cov5" title="3">openDeck.Cards = cards
        return &amp;openDeck, nil</span>
}

func (r PGDeckRepository) DrawCardFromDeck(ctx context.Context, deckID uuid.UUID, count int) error <span class="cov4" title="2">{
        findDeckIDQuery := `SELECT id FROM decks WHERE external_id = $1`
        var ID int
        err := r.DB.QueryRowContext(ctx, findDeckIDQuery, deckID).Scan(&amp;ID)
        if err != nil </span><span class="cov1" title="1">{
                if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                        return repository.ErrorDeckNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov1" title="1">updateQuery := `UPDATE decks_cards
        SET is_drew = true 
        WHERE id IN
        (
                SELECT id
                FROM decks_cards
                WHERE deck_id = $1
                AND is_drew = false 
                ORDER BY id desc
                LIMIT $2
        )`

        _, err = r.DB.ExecContext(ctx, updateQuery, ID, count)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (r PGDeckRepository) FetchDrewCards(ctx context.Context, deckID uuid.UUID) ([]repository.Card, error) <span class="cov0" title="0">{
        query := `
                SELECT c.suit, c.value, c.code
                FROM decks d
                INNER JOIN decks_cards dc
                ON d.id = dc.deck_id
                INNER JOIN cards c
                ON c.id = dc.card_id
                WHERE d.external_id = $1
                AND dc.is_drew IS true
        `
        rows, err := r.DB.QueryContext(ctx, query, deckID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var cards []repository.Card
        for rows.Next() </span><span class="cov0" title="0">{
                var card repository.Card
                err := rows.Scan(&amp;card.Suit, &amp;card.Value, &amp;card.Code)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">cards = append(cards, card)</span>
        }

        <span class="cov0" title="0">return cards, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package pg

import (
        "context"
        "database/sql"
        "testing"

        pg_container "github.com/jonss/testcontainers-go-wrapper/pg"
)

/*
--- NewDbTestSetup does:
-         configures a container with postgres,
-         creates a connection
-         run migration
*/
func NewDbTestSetup(t *testing.T) (*sql.DB, func()) <span class="cov10" title="9">{
        cfg := pg_container.PostgresCfg{
                ImageName: "postgres:15-alpine",
                Password:  "a_secret_password",
                UserName:  "test",
                DbName:    "posterr_test",
        }

        pgInfo, err := pg_container.Container(context.Background(), cfg)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("error creating pgContainer. error=(%v)", err)
        }</span>

        <span class="cov10" title="9">dbConn, err := NewConnection(pgInfo.DbURL)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("error connecting db. error=(%v)", err)
        }</span>

        <span class="cov10" title="9">err = Migrate(dbConn, cfg.DbName, "migrations")

        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("error connecting db. error=(%v)", err)
        }</span>

        <span class="cov10" title="9">return dbConn, pgInfo.TearDown</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package httprest

import (
        "errors"
        "net/http"
        "strings"

        "github.com/Jonss/cartaman/pkg/adapters/repository"
        "github.com/Jonss/cartaman/pkg/usecase/deck"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
)

var deckNotFoundMessage = "deck not found"
var deckIdIsInvalidMessage = "deck id is invalid"

func (a app) Create(c *fiber.Ctx) error <span class="cov5" title="3">{
        cardCodes := getCardCodes(c.Query("cards", ""))
        shuffled := c.QueryBool("shuffled", false)

        deck, err := a.DeckService.Create(c.UserContext(), deck.CreateParams{
                CardCodes: cardCodes,
                Shuffled:  shuffled,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.Status(http.StatusInternalServerError).SendString("error")
                return err
        }</span>
        <span class="cov5" title="3">return c.Status(http.StatusCreated).JSON(deck)</span>
}

func getCardCodes(codes string) []string <span class="cov5" title="3">{
        if len(codes) == 0 </span><span class="cov3" title="2">{
                return []string{}
        }</span>
        <span class="cov1" title="1">return strings.Split(codes, ",")</span>
}

func (a app) Open(c *fiber.Ctx) error <span class="cov5" title="3">{
        deckID, err := getDeckID(c)
        if err != nil </span><span class="cov1" title="1">{
                return c.Status(http.StatusBadRequest).SendString(deckIdIsInvalidMessage)
        }</span>

        <span class="cov3" title="2">openDeck, err := a.DeckService.Open(c.UserContext(), deckID)
        if err != nil </span><span class="cov1" title="1">{
                if err == repository.ErrorDeckNotFound </span><span class="cov1" title="1">{
                        return c.Status(http.StatusNotFound).SendString(deckNotFoundMessage)
                }</span>
                <span class="cov0" title="0">return c.Status(http.StatusBadRequest).SendString(err.Error())</span>
        }
        <span class="cov1" title="1">return c.JSON(openDeck)</span>
}

type DrawCardsResponse struct {
        Cards []deck.Card `json:"cards"`
}

func (a app) Draw(c *fiber.Ctx) error <span class="cov8" title="6">{
        deckID, err := getDeckID(c)
        if err != nil </span><span class="cov1" title="1">{
                return c.Status(http.StatusBadRequest).SendString(deckIdIsInvalidMessage)
        }</span>

        <span class="cov7" title="5">count, err := c.ParamsInt("count", 0)
        if err != nil || (count &lt;= 0) </span><span class="cov5" title="3">{
                return c.Status(http.StatusBadRequest).SendString("count should be above 0")
        }</span>
        <span class="cov3" title="2">drawDeck, err := a.DeckService.Draw(c.UserContext(), deckID, count)
        if err != nil </span><span class="cov1" title="1">{
                if err == repository.ErrorDeckNotFound </span><span class="cov1" title="1">{
                        return c.Status(http.StatusNotFound).SendString(deckNotFoundMessage)
                }</span>
                <span class="cov0" title="0">return c.Status(http.StatusBadRequest).SendString(err.Error())</span>
        }
        <span class="cov1" title="1">return c.JSON(DrawCardsResponse{drawDeck})</span>
}

func getDeckID(c *fiber.Ctx) (uuid.UUID, error) <span class="cov10" title="9">{
        paramID := c.Params("id")

        deckID, err := uuid.Parse(paramID)
        if err != nil </span><span class="cov3" title="2">{
                return uuid.Nil, errors.New("error id pattern unexpected")
        }</span>
        <span class="cov8" title="7">return deckID, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package httprest

import (
        "github.com/Jonss/cartaman/pkg/usecase/deck"
        "github.com/gofiber/fiber/v2"
)

type app struct {
        FiberApp    *fiber.App
        DeckService deck.DeckService
}

func NewApp(fiberApp *fiber.App, deckService deck.DeckService) app <span class="cov10" title="12">{
        return app{FiberApp: fiberApp, DeckService: deckService}
}</span>

func (a app) Routes() <span class="cov10" title="12">{
        a.FiberApp.Post("/decks", func(c *fiber.Ctx) error </span><span class="cov4" title="3">{
                return a.Create(c)
        }</span>)

        <span class="cov10" title="12">a.FiberApp.Get("/decks/:id", func(c *fiber.Ctx) error </span><span class="cov4" title="3">{
                return a.Open(c)
        }</span>)

        <span class="cov10" title="12">a.FiberApp.Patch("/decks/:id/draw/:count", func(c *fiber.Ctx) error </span><span class="cov7" title="6">{
                return a.Draw(c)
        }</span>)
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package deck

import "github.com/Jonss/cartaman/pkg/adapters/repository"

func mapCards(repoCards []repository.Card) []Card <span class="cov0" title="0">{
        cards := make([]Card, len(repoCards))
        for i, repoCard := range repoCards </span><span class="cov0" title="0">{
                cards[i] = Card{
                        Value: repoCard.Value,
                        Suit:  repoCard.Suit,
                        Code:  repoCard.Code,
                }
        }</span>
        <span class="cov0" title="0">return cards</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package deck

import (
        "context"
        "math/rand"

        "github.com/Jonss/cartaman/pkg/adapters/repository"
        "github.com/google/uuid"
)

type CreateParams struct {
        CardCodes []string
        Shuffled  bool
}

func (r *deckService) Create(ctx context.Context, params CreateParams) (*Deck, error) <span class="cov0" title="0">{
        cardIDs, err := r.CardRepository.GetCardIDs(ctx, params.CardCodes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if params.Shuffled </span><span class="cov0" title="0">{
                shuffleCards(cardIDs)
        }</span>
        <span class="cov0" title="0">externalID := uuid.New()
        deck, err := r.DeckRepository.CreateDeck(ctx, repository.CreateDeckParams{
                ExternalID: externalID,
                CardIDs:    cardIDs,
                Shuffled:   params.Shuffled,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Deck{
                DeckID:    deck.ExternalID,
                Shuffled:  deck.Shuffled,
                Remaining: deck.Remaining,
        }, nil</span>
}

func shuffleCards(cardIDs []int) <span class="cov0" title="0">{
        rand.Shuffle(len(cardIDs), func(i, j int) </span><span class="cov0" title="0">{
                cardIDs[i], cardIDs[j] = cardIDs[j], cardIDs[i]
        }</span>)
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package deck

import (
        "context"

        "github.com/Jonss/cartaman/pkg/adapters/repository"
        "github.com/google/uuid"
)

type Deck struct {
        DeckID    uuid.UUID `json:"deck_id"`
        Shuffled  bool      `json:"shuffled"`
        Remaining int       `json:"remaining"`
}

type Card struct {
        Value string `json:"value"`
        Suit  string `json:"suit"`
        Code  string `json:"code"`
}

type OpenDeck struct {
        DeckID    uuid.UUID `json:"deck_id"`
        Shuffled  bool      `json:"shuffled"`
        Remaining int       `json:"remaining"`
        Cards     []Card    `json:"cards"`
}

type deckService struct {
        DeckRepository repository.DeckRepository
        CardRepository repository.CardRepository
}

type DeckService interface {
        Create(context.Context, CreateParams) (*Deck, error)
        Open(context.Context, uuid.UUID) (*OpenDeck, error)
        Draw(context.Context, uuid.UUID, int) ([]Card, error)
}

func NewDeckService(
        deckRepository repository.DeckRepository,
        cardRepository repository.CardRepository) deckService <span class="cov0" title="0">{
        return deckService{
                DeckRepository: deckRepository,
                CardRepository: cardRepository,
        }
}</span>

var _ DeckService = (*deckService)(nil)
</pre>
		
		<pre class="file" id="file9" style="display: none">package deck

import (
        "context"

        "github.com/google/uuid"
)

func (r *deckService) Draw(ctx context.Context, deckID uuid.UUID, count int) ([]Card, error) <span class="cov0" title="0">{
        err := r.DeckRepository.DrawCardFromDeck(ctx, deckID, count)
        if err != nil </span><span class="cov0" title="0">{
                return []Card{}, err
        }</span>

        <span class="cov0" title="0">cards, err := r.DeckRepository.FetchDrewCards(ctx, deckID)
        if err != nil </span><span class="cov0" title="0">{
                return []Card{}, err
        }</span>

        <span class="cov0" title="0">return mapCards(cards), nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/Jonss/cartaman/pkg/usecase/deck (interfaces: DeckService)

// Package mock_deck is a generated GoMock package.
package mock_deck

import (
        context "context"
        reflect "reflect"

        deck "github.com/Jonss/cartaman/pkg/usecase/deck"
        gomock "github.com/golang/mock/gomock"
        uuid "github.com/google/uuid"
)

// MockDeckService is a mock of DeckService interface.
type MockDeckService struct {
        ctrl     *gomock.Controller
        recorder *MockDeckServiceMockRecorder
}

// MockDeckServiceMockRecorder is the mock recorder for MockDeckService.
type MockDeckServiceMockRecorder struct {
        mock *MockDeckService
}

// NewMockDeckService creates a new mock instance.
func NewMockDeckService(ctrl *gomock.Controller) *MockDeckService <span class="cov10" title="12">{
        mock := &amp;MockDeckService{ctrl: ctrl}
        mock.recorder = &amp;MockDeckServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeckService) EXPECT() *MockDeckServiceMockRecorder <span class="cov8" title="7">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockDeckService) Create(arg0 context.Context, arg1 deck.CreateParams) (*deck.Deck, error) <span class="cov4" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", arg0, arg1)
        ret0, _ := ret[0].(*deck.Deck)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockDeckServiceMockRecorder) Create(arg0, arg1 interface{}) *gomock.Call <span class="cov4" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockDeckService)(nil).Create), arg0, arg1)
}</span>

// Draw mocks base method.
func (m *MockDeckService) Draw(arg0 context.Context, arg1 uuid.UUID, arg2 int) ([]deck.Card, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Draw", arg0, arg1, arg2)
        ret0, _ := ret[0].([]deck.Card)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Draw indicates an expected call of Draw.
func (mr *MockDeckServiceMockRecorder) Draw(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Draw", reflect.TypeOf((*MockDeckService)(nil).Draw), arg0, arg1, arg2)
}</span>

// Open mocks base method.
func (m *MockDeckService) Open(arg0 context.Context, arg1 uuid.UUID) (*deck.OpenDeck, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Open", arg0, arg1)
        ret0, _ := ret[0].(*deck.OpenDeck)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Open indicates an expected call of Open.
func (mr *MockDeckServiceMockRecorder) Open(arg0, arg1 interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Open", reflect.TypeOf((*MockDeckService)(nil).Open), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package deck

import (
        "context"

        "github.com/google/uuid"
)

func (r *deckService) Open(ctx context.Context, deckID uuid.UUID) (*OpenDeck, error) <span class="cov0" title="0">{
        openDeck, err := r.DeckRepository.FetchDeck(ctx, deckID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;OpenDeck{
                DeckID:    openDeck.Deck.ExternalID,
                Remaining: openDeck.Deck.Remaining,
                Cards:     mapCards(openDeck.Cards),
        }, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
